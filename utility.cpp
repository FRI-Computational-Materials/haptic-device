#include "utility.h"
#include <sys/stat.h>
#include <sys/types.h>
#include <cctype>
#include <fstream>
#include <iostream>
#include <string>
#include "globals.h"

// a font for rendering text
chai3d::cFontPtr font = chai3d::NEW_CFONTCALIBRI20();

// font for help screen
chai3d::cFontPtr helpFont = chai3d::NEW_CFONTCALIBRI32();

// check if file already exists in directory
bool fileExists(const std::string &name) {
  struct stat buffer;
  return (stat(name.c_str(), &buffer) == 0);
}

// read in global minimum by cluster size
double getGlobalMinima(int cluster_size) {
  std::string file_path = "../resources/data/";
  std::string file_name = "global_minima.txt";
  std::ifstream infile(file_path + file_name);
  if (!infile) {
    std::cerr << "Could not open \"" + file_name + "\" for reading"
              << std::endl;
    std::cerr << "Did you move it to \"" + file_path + "\"?" << std::endl;
    exit(1);
  } else if ((cluster_size < 2) || (cluster_size > 150)) {
    std::cout << "WARNING: \"" + file_name +
                     "\" doesn't have data for clusters of this size yet."
              << std::endl;
    std::cout << "The graph may not be accurate." << std::endl;
    return 0;
  }

  int cluster_size_file;
  double minimum;
  while (infile >> cluster_size_file >> minimum) {
    if (cluster_size_file == cluster_size) {
      break;
    }
  }
  // std::cout << "Global minimum:" << minimum << std::endl;
  return minimum;
}

// check if char array represents a number
bool isNumber(char number[]) {
  for (int i = 0; number[i] != 0; i++) {
    if (!isdigit(number[i])) return false;
  }
  return true;
}

// add help panel labels
void addHotkeyLabel(std::string keys, std::string function) {
  chai3d::cLabel *tempKeyLabel = new chai3d::cLabel(helpFont);
  chai3d::cLabel *tempFuncLabel = new chai3d::cLabel(helpFont);
  tempKeyLabel->m_fontColor.setBlack();
  tempFuncLabel->m_fontColor.setBlack();
  tempKeyLabel->setText(keys);
  tempFuncLabel->setText(function);
  tempKeyLabel->setShowPanel(false);
  tempFuncLabel->setShowPanel(false);
  hotkeyKeys.push_back(tempKeyLabel);
  hotkeyFunctions.push_back(tempFuncLabel);
}

// add status labels
void addLabel(chai3d::cLabel *&label) {
  label = new chai3d::cLabel(font);
  label->m_fontColor.setBlack();
  camera->m_frontLayer->addChild(label);
}

// update camera label
void updateCameraLabel(chai3d::cLabel *&camera_pos, chai3d::cCamera *&camera) {
  camera_pos->setText(
      "Camera located at: (" +
      chai3d::cStr(rho * sin(camera->getSphericalPolarRad()) *
                   cos(camera->getSphericalAzimuthRad())) +
      ", " +
      chai3d::cStr(rho * sin(camera->getSphericalPolarRad()) *
                   sin(camera->getSphericalAzimuthRad())) +
      ", " + chai3d::cStr(rho * cos(camera->getSphericalPolarRad())) + ")");
}

//
void writeToCon(std::string fileName) {
  ofstream writeFile;
  writeFile.open(fileName);
  writeFile << "Generated by haptic device" << endl << endl;
  writeFile << "100.000000   100.000000   100.000000" << endl
            << "90.000000    90.000000    90.000000" << endl
            << endl
            << endl;
  writeFile << "1" << endl
            << spheres.size() << endl
            << "1.007940" << endl
            << "H" << endl
            << "Coordinates of Component 1" << endl;
  writeFile.precision(7);
  writeFile << centerCoords[0] << " " << centerCoords[1] << " "
            << centerCoords[2] << " 0 0" << endl;
  for (int i = 1; i < spheres.size(); i++) {
    chai3d::cVector3d pos = spheres[i]->getLocalPos();
    writeFile << (pos.x() / 0.02) + centerCoords[0] << " "
              << (pos.y() / 0.02) + centerCoords[1] << " "
              << (pos.z() / 0.02) + centerCoords[2] << " 0 " << i << endl;
  }
  writeFile.close();
}

// Create directory if it doesn't exist and returns the directory name
void createDir(std::string dir_name) {
  // Create root directory
  ofstream write_dir;
  struct stat buffer;
  if (stat(dir_name.c_str(), &buffer) != 0) {
    char cstr[dir_name.size() + 1];
    strcpy(cstr, dir_name.c_str());
    mkdir(cstr, 0777);
  }
}

std::string createDateDir(std::string root_dir) {
  // Create date folder
  time_t now = time(0);
  tm *ltm = localtime(&now);
  int year = 1900 + ltm->tm_year;
  int month = 1 + ltm->tm_mon;
  int day = ltm->tm_mday;
  string date = to_string(month) + "-" + to_string(day) + "-" + to_string(year);
  string date_dir = root_dir + date + "/";
  createDir(date_dir);
  return date_dir;
}
