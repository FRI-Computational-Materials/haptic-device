#include "globals.h"
#include "utility.h"
#include <cctype>
#include <sys/types.h>
#include <sys/stat.h>
#include <fstream>
#include <iostream>
#include <string>

// a font for rendering text
chai3d::cFontPtr font = chai3d::NEW_CFONTCALIBRI20();

// font for help screen
chai3d::cFontPtr helpFont = chai3d::NEW_CFONTCALIBRI32();

// check if file already exists in directory
bool fileExists(const std::string &name) {
  struct stat buffer;
  return (stat(name.c_str(), &buffer) == 0);
}

//read in global minimum by cluster size
double getGlobalMinima(int cluster_size) {
  std::string file_path = "../resources/data/";
  std::string file_name = "global_minima.txt";
  std::ifstream infile(file_path + file_name);
  if (!infile) {
    std::cerr << "Could not open \"" + file_name + "\" for reading" << std::endl;
    std::cerr << "Did you move it to \"" + file_path + "\"?" << std::endl;
    exit(1);
  } else if ((cluster_size < 2) || (cluster_size > 150)) {
    std::cout << "WARNING: \"" + file_name +
                "\" doesn't have data for clusters of this size yet."
         << std::endl;
    std::cout << "The graph may not be accurate." << std::endl;
    return 0;
  }

  int cluster_size_file;
  double minimum;
  while (infile >> cluster_size_file >> minimum) {
    if (cluster_size_file == cluster_size) {
      break;
    }
  }
  //std::cout << "Global minimum:" << minimum << std::endl;
  return minimum;
}

// check if char array represents a number
bool isNumber(char number[]) {
  for (int i = 0; number[i] != 0; i++) {
    if (!isdigit(number[i])) return false;
  }
  return true;
}

//add help panel labels
void addHotkeyLabel(std::string keys, std::string function){
  chai3d::cLabel *tempKeyLabel = new chai3d::cLabel(helpFont);
  chai3d::cLabel *tempFuncLabel = new chai3d::cLabel(helpFont);
  tempKeyLabel->m_fontColor.setBlack();
  tempFuncLabel->m_fontColor.setBlack();
  tempKeyLabel->setText(keys);
  tempFuncLabel->setText(function);
  tempKeyLabel->setShowPanel(false);
  tempFuncLabel->setShowPanel(false);
  hotkeyKeys.push_back(tempKeyLabel);
  hotkeyFunctions.push_back(tempFuncLabel);
}

// add status labels
void addLabel(chai3d::cLabel *&label) {
    label = new chai3d::cLabel(font);
    label->m_fontColor.setBlack();
    camera->m_frontLayer->addChild(label);
}

// update camera label
void updateCameraLabel(chai3d::cLabel *&camera_pos, chai3d::cCamera *&camera) {
    camera_pos->setText("Camera located at: (" +
                        chai3d::cStr(rho * sin(camera->getSphericalPolarRad()) *
                             cos(camera->getSphericalAzimuthRad())) +
                        ", " +
                        chai3d::cStr(rho * sin(camera->getSphericalPolarRad()) *
                             sin(camera->getSphericalAzimuthRad())) +
                        ", " + chai3d::cStr(rho * cos(camera->getSphericalPolarRad())) +
                        ")");
}

//
void writeToCon(std::string fileName) {
    ofstream writeFile;
    writeFile.open(fileName);
    writeFile << "Generated by haptic device" << endl << endl;
    writeFile << "100.000000   100.000000   100.000000" << endl
    << "90.000000    90.000000    90.000000" << endl
    << endl
    << endl;
    writeFile << "1" << endl
    << spheres.size() << endl
    << "1.007940" << endl
    << "H" << endl
    << "Coordinates of Component 1" << endl;
    writeFile.precision(7);
    writeFile << centerCoords[0] << " " << centerCoords[1] << " "
    << centerCoords[2] << " 0 0" << endl;
    for (int i = 1; i < spheres.size(); i++) {
        chai3d::cVector3d pos = spheres[i]->getLocalPos();
        writeFile << (pos.x() / 0.02) + centerCoords[0] << " "
        << (pos.y() / 0.02) + centerCoords[1] << " "
        << (pos.z() / 0.02) + centerCoords[2] << " 0 " << i << endl;
    }
    writeFile.close();
}
